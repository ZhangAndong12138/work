# JavaWeb项目规范

## 1. 命名规范
### 1.1 类命名规范
类名使用`UpperCamelCase`风格，必须遵从驼峰形式，但以下情形例外:DO / BO / DTO / VO / AO

正例：
> MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion

反例：
> macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion

### 1.1.1 Service层类命名规范
Service层必须有接口和实现类，其中接口名称为`业务名称+Service`，实现类名称为`接口名称+Impl`
注意业务名称与数据库表名的区分，业务名称开头并没有额外的`T`。

### 1.1.2 DAO层、Model层命名规范
目前项目的DAO层和Model层是通过`mybatis-generator`插件自动生成的，不允许自行改动类名。

### 1.2 方法名、变量命名规范
方法名、参数名、成员变量、局部变量都统一使用`lowerCamelCase`风格，必须遵从驼峰形式。

正例：
> localValue / getHttpMessage() / inputUserId

### 1.3 常量命名规范
常量命名**全部大写**，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。

### 1.4 枚举命名规范
枚举类名建议带上 Enum 后缀，枚举成员名称需要`全部大写`，单词间用下划线隔开。

### 1.5 @RequestMapping命名规范
#### 1.5.1 URL命名原则
URL请求采用小写字母，数字，部分特殊符号（非制表符）组成。

URL请求中**不采用**大小写混合的驼峰命名方式，采用全小写单词，如果需要连接多个单词，则采用连接符“_”连接单词

#### 1.5.2 URL分级
第一级Pattern为模块,同一模块的功能应当保持第一级Pattern一致

正例：
> 任务管理:/task/xxx
> 
> 舆材管理:/material/xxx

第二级Pattern为资源分类或者功能请求，优先采用资源分类

正例：
> 任务管理-指令:/task/instruction (资源分类)
> 
> 舆材管理-查询:/material/query (功能请求)

### 1.6 Service/DAO层方法命名规约 

>   1) 获取单个对象的方法用get做前缀。  
>   2) 获取多个对象的方法用list做前缀。  
>   3) 获取统计值的方法用count做前缀。  
>   4) 插入的方法用save/insert做前缀。  
>   5) 删除的方法用remove/delete做前缀。  
>   6) 修改的方法用update做前缀。  

## 2. 代码格式
### 2.1 大括号
如果是大括号内为空，则简洁地写成`{}`即可，不需要换行;如果是非空代码块则:
- 左大括号前不换行。
- 左大括号后换行。
- 右大括号前换行。
- 右大括号后还有else等代码则不换行;表示终止的右大括号后必须换行。

### 2.2 空格
- 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。
- if/for/while/switch/do 等保留字与括号之间都必须加空格。
- 任何二目、三目运算符的左右两边都需要加一个空格。
- 注释的双斜线与注释内容之间有且仅有一个空格。

正例：
>```java
>public static void main(String[] args) {
>    String say = "hello";
>    // 运算符的左右必须有一个空格
>    int flag = 0;
>    // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格
>    if (flag == 0) {
>        System.out.println(say);
>    }
>    // 左大括号前加空格且不换行;左大括号后换行
>    if (flag == 1) {
>        System.out.println("world");
>        // 右大括号前换行，右大括号后有 else，不用换行
>    } else {
>        System.out.println("ok");
>        // 在右大括号后直接结束，则必须换行
>    }
>}
>```

### 2.3 空行
推荐：
- 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。
- 没有必要插入多个空行进行隔开。

## 3. OOP规约
### 3.1 访问静态变量和静态方法
避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。

### 3.2 @Override
所有的覆写方法，必须加@Override 注解。

### 3.3 过时的类或方法
不能使用过时的类或方法。

### 3.4 equals()方法
Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。

正例：
> "test".equals(object);

反例：
> object.equals("test");

### 3.5 实体类的默认值
定义POJO 类时，不要设定任何属性默认值。

反例：
> POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具 体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。

## 4. 注释规约
### 4.1 Javadoc注释
类、类属性、类方法的注释**必须**使用`Javadoc`规范，使用`/**内容*/`格式，不得使用// xxx方式。

### 4.2 抽象方法注释
所有的抽象方法(包括接口中的方法)必须要用`Javadoc`注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。

### 4.3 类注释
所有的类都必须添加创建者`@author`和创建日期`@since`。

### 4.4 方法内部注释
方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释，注意与代码对齐。

### 4.5 修改注释
代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑 等的修改。

### 4.6 特殊注释标记(参考)
- 待办事宜(`TODO`):(标记人，标记时间，[预计处理时间])
表示需要实现，但目前还未实现的功能。这实际上是一个`Javadoc`的标签，目前的`Javadoc`还没有实现，但已经被广泛使用。只能应用于类，接口和方法(因为它是一个`Javadoc`标签)。
- 错误，不能工作(`FIXME`):(标记人，标记时间，[预计处理时间])
在注释中用`FIXME`标记某代码是错误的，而且不能工作，需要及时纠正的情况。

## 5. 日志规约
### 5.1 预先检查可规避的异常
Java 类库中定义的一类`RuntimeException`可以通过预先检查进行规避，而不应该 通过catch来处理，比如:`IndexOutOfBoundsException`，`NullPointerException`等等。

### 5.2 不要用异常来做流程控制
异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。

### 5.3 注意try-catch的范围
对大段代码进行`try-catch`，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。

### 5.4 处理异常
- 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。

### 5.5 回滚事务
- 有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。

### 5.6 关闭资源对象、流对象
- finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。可以使用`try-with-resources`方式。

### 5.7 不能在 finally 块中使用 return
不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不 会再执行 try 块中的 return 语句。

### 5.8 抛异常
捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。

## 6. 版本控制规范
### 6.1 定期更新
定期更新所有相关代码，降低代码冲突的概率。建议每天更新。

### 6.2 提交规范
多提交，每次提交的时候内容少一点。
#### 6.2.1 及时提交代码
- 完成某个功能点的开发后（如完成了保存功能），应当及时提交相关代码，避免等到整个功能模块开发完成才提交一堆文件的情况发生。
- 修改工具类、配置类、枚举类、实体类、Mapper等共用概率较大的文件时，应在修改完成后**立即**提交。

#### 6.2.2 先更新，再提交
在提交代码之前，**必须**先更新代码。如果遇到冲突，应当按正确的方式进行Merge（见6.3）。

#### 6.2.3 写明详细的提交信息
提交代码时，**必须**写明详细的提交信息，包括开发了什么模块的什么功能，提交人，提交时间。如有必要，还需要写明修改了哪些文件。

格式：
> 开发功能信息_提交人@提交时间

正例：
> 开发舆情管理保存功能_zad@20191010

反例：
> 修改MaterialController_zad@20191010
> 
> 开发保存_zad@20191010
> 
> 开发
> 
> 20191010

#### 6.2.4 不要提交不能通过编译的代码
- **必须**确认要提交的文件内没有编译错误
- 充分考虑提交的文件是否会引起其它文件的编译错误
- 保证相关代码全部提交，避免出现提交了`xxxService`但没有提交`xxxServiceImpl`的情况

#### 6.2.5 不要提交本地自动生成的文件
合理使用SVN的`ignore`功能，避免提交本地自动生成的文件。例如eclipse中的.classpath文件、项目编译生成的.class文件、target文件夹等等。

#### 6.2.6 不要提交自己看不懂的代码
在引入任何第三方代码之前，确保你对引入的代码有充分的的理解，否则不要提交。

### 6.3 合并规范
如果和其他人修改了同一个文件，更新代码时，svn会自动对代码进行合并，如果修改的是同一行，合并时会产生冲突，这时你需要进行手动合并(Merge)。这种情况，需要同之前的开发人员沟通，两人协商解决冲突。即使冲突代码看起来比较简单，也需要与之前的开发人员沟通，切忌自行随意合并。





